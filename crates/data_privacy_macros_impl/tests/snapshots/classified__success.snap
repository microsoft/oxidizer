---
source: crates/data_privacy_macros_impl/tests/classified.rs
expression: pretty
---
struct EmailAddress(String);
impl ::data_privacy::Classified for EmailAddress {
    fn data_class(&self) -> &::data_privacy::DataClass {
        ExampleTaxonomy::PersonallyIdentifiableInformation.as_ref()
    }
}
impl ::core::fmt::Debug for EmailAddress {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let dc = <Self as ::data_privacy::Classified>::data_class(self);
        write!(f, "<CLASSIFIED:{}/{}>", dc.taxonomy(), dc.name())
    }
}
impl ::core::fmt::Display for EmailAddress {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let dc = <Self as ::data_privacy::Classified>::data_class(self);
        write!(f, "<CLASSIFIED:{}/{}>", dc.taxonomy(), dc.name())
    }
}
impl ::data_privacy::RedactedDebug for EmailAddress {
    #[expect(
        clippy::cast_possible_truncation,
        reason = "Converting from u64 to usize, value is known to be <= STACK_BUFFER_SIZE"
    )]
    fn fmt(
        &self,
        engine: &::data_privacy::RedactionEngine,
        output: &mut ::std::fmt::Formatter<'_>,
    ) -> ::core::fmt::Result {
        const STACK_BUFFER_SIZE: usize = 128;
        let v = &self.0;
        let dc = <Self as ::data_privacy::Classified>::data_class(self);
        let mut local_buf = [0u8; STACK_BUFFER_SIZE];
        let amount = {
            let mut cursor = ::std::io::Cursor::new(&mut local_buf[..]);
            if ::std::io::Write::write_fmt(&mut cursor, format_args!("{v:?}")).is_ok() {
                cursor.position() as usize
            } else {
                local_buf.len() + 1
            }
        };
        if amount <= local_buf.len() {
            let s = unsafe { ::core::str::from_utf8_unchecked(&local_buf[..amount]) };
            engine.redact(dc, s, output)
        } else {
            engine.redact(dc, format!("{v:?}"), output)
        }
    }
}
impl ::data_privacy::RedactedDisplay for EmailAddress {
    #[expect(
        clippy::cast_possible_truncation,
        reason = "Converting from u64 to usize, value is known to be <= STACK_BUFFER_SIZE"
    )]
    fn fmt(
        &self,
        engine: &::data_privacy::RedactionEngine,
        output: &mut ::std::fmt::Formatter,
    ) -> ::core::fmt::Result {
        const STACK_BUFFER_SIZE: usize = 128;
        let v = &self.0;
        let dc = <Self as ::data_privacy::Classified>::data_class(self);
        let mut local_buf = [0u8; STACK_BUFFER_SIZE];
        let amount = {
            let mut cursor = ::std::io::Cursor::new(&mut local_buf[..]);
            if ::std::io::Write::write_fmt(&mut cursor, format_args!("{v}")).is_ok() {
                cursor.position() as usize
            } else {
                local_buf.len() + 1
            }
        };
        if amount <= local_buf.len() {
            let s = unsafe { ::core::str::from_utf8_unchecked(&local_buf[..amount]) };
            engine.redact(dc, s, output)
        } else {
            engine.redact(dc, format!("{v}"), output)
        }
    }
}
impl core::ops::Deref for EmailAddress {
    type Target = ::core::convert::Infallible;
    fn deref(&self) -> &Self::Target {
        panic!("Deref to Infallible should never happen")
    }
}
impl ::core::ops::DerefMut for EmailAddress {
    fn deref_mut(&mut self) -> &mut Self::Target {
        panic!("Deref to Infallible should never happen")
    }
}
