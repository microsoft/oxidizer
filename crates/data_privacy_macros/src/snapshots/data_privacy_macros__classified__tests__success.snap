---
source: crates/data_privacy_macros/src/classified.rs
expression: pretty
---
struct EmailAddress(String);
impl EmailAddress {
    /// Exfiltrates the payload, allowing it to be used outside the classified context.
    ///
    /// Exfiltration should be done with caution, as it may expose sensitive information.
    ///
    /// # Returns
    /// The original payload.
    #[must_use]
    fn declassify(self) -> String {
        self.0
    }
    /// Provides a reference to the declassified payload, allowing read access without ownership transfer.
    ///
    /// Exfiltration should be done with caution, as it may expose sensitive information.
    ///
    /// # Returns
    /// A reference to the original payload.
    #[must_use]
    fn as_declassified(&self) -> &String {
        &self.0
    }
    /// Provides a mutable reference to the declassified payload, allowing write access without ownership transfer.
    ///
    /// Exfiltration should be done with caution, as it may expose sensitive information.
    ///
    /// # Returns
    /// A mutable reference to the original payload.
    #[must_use]
    fn as_declassified_mut(&mut self) -> &mut String {
        &mut self.0
    }
    /// Returns the data class of the payload.
    #[must_use]
    fn data_class(&self) -> data_privacy::DataClass {
        ExampleTaxonomy::PersonallyIdentifiableInformation.data_class()
    }
}
impl data_privacy::Classified for EmailAddress {
    type Payload = String;
    fn declassify(self) -> Self::Payload {
        Self::declassify(self)
    }
    fn as_declassified(&self) -> &Self::Payload {
        Self::as_declassified(self)
    }
    fn as_declassified_mut(&mut self) -> &mut Self::Payload {
        Self::as_declassified_mut(self)
    }
    fn data_class(&self) -> data_privacy::DataClass {
        Self::data_class(self)
    }
}
impl core::fmt::Debug for EmailAddress {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_fmt(::core::format_args!("<CLASSIFIED:{}>", self.data_class()))
    }
}
impl core::fmt::Display for EmailAddress {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_fmt(::core::format_args!("<CLASSIFIED:{}>", self.data_class()))
    }
}
impl core::ops::Deref for EmailAddress {
    type Target = core::convert::Infallible;
    fn deref(&self) -> &Self::Target {
        todo!()
    }
}
impl core::ops::DerefMut for EmailAddress {
    fn deref_mut(&mut self) -> &mut Self::Target {
        todo!()
    }
}
