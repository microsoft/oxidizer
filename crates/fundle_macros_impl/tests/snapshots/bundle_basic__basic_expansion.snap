---
source: crates/fundle_macros_impl/tests/bundle_basic.rs
expression: expand_fundle_bundle!(item)
---
#[allow(non_camel_case_types, non_snake_case)]
struct Foo {}
#[allow(non_camel_case_types, non_snake_case, clippy::items_after_statements)]
impl Foo {
    pub fn builder() -> FooBuilder {
        FooBuilder::default()
    }
}
#[allow(non_camel_case_types, dead_code, non_snake_case, clippy::items_after_statements)]
struct FooBuilder {
    _phantom: ::std::marker::PhantomData<()>,
}
#[allow(non_camel_case_types, non_snake_case, clippy::items_after_statements)]
impl ::std::default::Default for FooBuilder {
    fn default() -> Self {
        Self {
            _phantom: ::std::marker::PhantomData,
        }
    }
}
impl ::fundle::exports::Exports for Foo {
    const NUM_EXPORTS: usize = 0usize;
}
#[allow(non_camel_case_types, non_snake_case, clippy::items_after_statements)]
impl FooBuilder {
    pub fn build(self) -> Foo {
        Foo {}
    }
}
#[allow(unused_macros, snake_case)]
macro_rules! Foo {
    (
        select($builder_var:ident) => $($forward_type:ident ($forward_field:ident)),*
        $(,)?
    ) => {
        { $(Foo!(verify_field $builder_var $forward_field);)*
        #[allow(non_camel_case_types, non_snake_case, clippy::items_after_statements)]
        struct Select < 'a, > { builder : & 'a FooBuilder < >, $($forward_type : & 'a
        $forward_type,)* } $(#[allow(non_camel_case_types, non_snake_case,
        clippy::items_after_statements)] impl < 'a, > ::std::convert::AsRef <
        $forward_type > for Select < 'a, > { fn as_ref(& self) -> & $forward_type { self.
        $forward_type } })* Select { builder : & $builder_var, $($forward_type :
        $builder_var . $forward_field .as_ref().unwrap(),)* } }
    };
}
