trigger:
- main

parameters:
- name: sourceBranch
  displayName: 'Source branch for checkout and PR target'
  type: string
  default: 'main'
- name: validationOsList
  type: object
  default:
  - linux
  - windows
- name: validationProfiles
  type: object
  default:
  - dev
  - release
- name: previousVersion
  type: string
  default: 'HEAD^'

variables:
  MSRUSTUP_TOOLCHAIN: ms-prod

resources:
  repositories:
  - repository: 1ESPipelineTemplates
    type: git
    name: 1ESPipelineTemplates/1ESPipelineTemplates
    ref: refs/tags/release

extends:
  template: v1/1ES.Official.PipelineTemplate.yml@1ESPipelineTemplates
  parameters:
    oneESTemplateTag: canary
    sdl:
      sourceAnalysisPool:
        name: $(agentPool)
    pool:
      name: $(agentPool)
    stages:
    # Workaround for https://github.com/crate-ci/cargo-release/issues/670
    # Since --unpublished doesn't work when private repositories are in the picture, we figure out which packages to
    # publish manually.
    - stage: determine_packages
      displayName: 'Determine packages to publish'
      jobs:
      - job: determine_packages
        displayName: 'Determine packages to publish'
        variables:
        # Run on linux where network isolation isn't enforced yet
        pool:
          name: ${{ parameters.agentPool }}
          os: linux
          image: ubuntu-latest
        templateContext:
          workflow: Rust
          rust:
            rustToolchain:
              toolchainFeed: $(toolchainFeed)
            cacheOptions:
              enabled: true
            command: custom
          setupSteps:
            - template: .ado/templates/create-cargo-config.yml@self
              parameters:
                registryUrl: $(InternalCratesIoMirror)
                registryName: CratesIoMirror
          postBuildSteps:
          - template: .ado/templates/determine-publish-packages.yml@self
            parameters:
              manifestPath: '$(Build.SourcesDirectory)/Cargo.toml'
              variableName: INTERNAL_MIRROR_PUBLISH_PACKAGES
              stepName: determine_packages_internal_mirror
              workingDirectory: '$(Build.SourcesDirectory)'
              registryName: CratesIoMirror
              previousVersion: ${{ parameters.previousVersion }}
          - template: .ado/templates/determine-publish-packages.yml@self
            parameters:
              manifestPath: '$(Build.SourcesDirectory)/Cargo.toml'
              variableName: CRATES_IO_PUBLISH_PACKAGES
              stepName: determine_packages_crates_io
              workingDirectory: '$(Pipeline.Workspace)' # We need to be outside of the folder with .cargo/config.toml to actually get info from crates.io
              registryName: crates-io
              previousVersion: ${{ parameters.previousVersion }}
    - stage: build
      displayName: 'Build and Test'
      dependsOn: []
      jobs:
      - ${{ each os in parameters.validationOsList }}:
        - ${{ each profile in parameters.validationProfiles }}:
          - job: build_test_${{ profile }}_${{ os }}
            displayName: 'Build and Test ${{ profile }} on ${{ os }}'
            pool:
              name: ${{ parameters.agentPool }}
              os: ${{ os }}
              ${{ if eq(os, 'linux') }}:
                image: ubuntu-latest
              ${{ else }}:
                image: windows-latest
            variables:
            - template: .ado/templates/cargo-tools.yml@self
            templateContext:
              workflow: Rust
              rust:
                rustToolchain:
                  toolchainFeed: $(toolchainFeed)
                profile: ${{ profile }}
                testOptions:
                  testDoc: true
                cacheOptions:
                  enabled: true
              setupSteps:
                - template: .ado/templates/create-cargo-config.yml@self
                  parameters:
                    registryUrl: $(InternalCratesIoMirror)
              preBuildSteps:
                - pwsh: |
                    Write-Host "Building with profile: ${{ profile }} on OS: ${{ os }}"
              postBuildSteps:
                - pwsh: |
                    Write-Host "Completed"
    # We first publish using Rust Release workflow to internal crates.io mirror. This serves two purposes:
    #
    # * It ensures compliance by using the Rust Release Workflow to publish first
    # * It makes sure the internal crates.io mirror contains all the crates we're publishing so the publish validation
    #   during crates.io publishing can pull dependencies from there rather than crates.io directly
    #   (without this first publishing step, crates.io publishing would fail due to missing dependencies)
    - stage: publish_staging
      displayName: 'Publish Staging'
      dependsOn: [build,determine_packages]
      variables:
      - name: PACKAGES_ARG
        value: $[ stageDependencies.determine_packages.determine_packages.outputs['determine_packages_internal_mirror.INTERNAL_MIRROR_PUBLISH_PACKAGES'] ]
      jobs:
      - job: publish
        displayName: 'Publish'
        condition: and(succeeded(), ne(variables['PACKAGES_ARG'], ''))
        variables:
        # The only way to provide Rust Release Workflow with the packages to publish - results in $(PACKAGES_ARG) being added to the cargo release command
        - name: 1ES_RUST_WORKFLOW_PUBLISH_EXTRA_ARGUMENTS
          value: $(PACKAGES_ARG)
        templateContext:
          type: releaseJob
          isProduction: true
          workflow: Rust
          inputs:
            # Build evidence as required by the Rust workflow
            - input: pipelineArtifact
              artifactName: RustBuildEvidence_x86_64-pc-windows-msvc_release
              targetPath: "$(Pipeline.Workspace)/rust_build_evidence/build_test_release_windows"
            - input: pipelineArtifact
              artifactName: RustBuildEvidence_x86_64-pc-windows-msvc_dev
              targetPath: "$(Pipeline.Workspace)/rust_build_evidence/build_test_dev_windows"
          setupSteps:
            - template: .ado/templates/create-cargo-config.yml@self
              parameters:
                registryUrl: $(InternalCratesIoMirror)
          rust:
            rustToolchain:
              toolchainFeed: $(toolchainFeed)
            releaseOptions:
              useCargoRelease: true
              registry: CratesIoMirror
              execute: true
              git:
                name: "Oxidizer Team"
                email: $(gitEmail)
    # Then, we publish to crates.io using a custom Rust workflow job because the release workflow
    # doesn't allow us to tag the commit or easily specify crates.io token. We want to have tags on commits
    # corresponding to the releases of individual crates for easier identification in the future.
    #
    # Importantly, we pull dependencies from the internal crates.io mirror, not from crates.io directly, so we're not
    # violating CFS requirements.
    - stage: publish
      displayName: 'Publish'
      dependsOn: [publish_staging,determine_packages]
      variables:
      - name: PACKAGES_ARG
        value: $[ stageDependencies.determine_packages.determine_packages.outputs['determine_packages_crates_io.CRATES_IO_PUBLISH_PACKAGES'] ]
      jobs:
      - job: publish
        displayName: 'Publish'
        condition: and(succeeded(), ne(variables['PACKAGES_ARG'], ''))
        variables:
        - template: .ado/templates/cargo-tools.yml@self
        # Run on linux where network isolation isn't enforced yet
        pool:
          name: ${{ parameters.agentPool }}
          os: linux
          image: ubuntu-latest
        templateContext:
          workflow: Rust
          rust:
            rustToolchain:
              toolchainFeed: $(toolchainFeed)
            cacheOptions:
              enabled: true
            command: custom
            customOptions:
              tools:
              - $(cargo-tools-cargo-release)
          setupSteps:
          - checkout: self
            persistCredentials: true
          - template: .ado/templates/create-cargo-config.yml@self
            parameters:
              registryUrl: $(InternalCratesIoMirror)
          - task: AzureKeyVault@2
            inputs:
              azureSubscription: $(serviceConnectionName)
              keyVaultName: $(keyVaultName)
              secretsFilter: CratesIoToken
          postBuildSteps:
          - pwsh: |
              git config --global user.name "Oxidizer Team"
              git config --global user.email "$(gitEmail)"
              Write-Host "Creating a named branch $(Build.BuildNumber)"
              git checkout -b release/$(Build.BuildNumber)
              Write-Host "Running cargo release for crates.io"
              $tokenLength = $env:CARGO_REGISTRY_TOKEN.Length
              Write-Host "CARGO_REGISTRY_TOKEN length: $tokenLength"
              cargo release $(PACKAGES_ARG) --registry crates-io --no-confirm --execute --allow-branch '*'
            env:
              CARGO_REGISTRY_TOKEN: $(CratesIoToken)
            displayName: 'Run cargo release'
